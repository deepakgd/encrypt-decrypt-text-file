npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/

npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
npx:
npx is a very cool way to run Node code, and provides many useful features

Node developers used to publish most of the executable commands as global packages, in order for them to be in the path
and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running npx commandname automatically finds the correct reference of the command inside the node_modules folder of a project,
without needing to know the exact path, and without requiring the package to be installed globally and in the user’s path.


Example:

inside project folder, npm install -D cowsay

then try npx cowsay hello

output:
_______
< hello >
 -------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


cowsay is commandline tool package if you install globally u can use cowsay directly in command line
to avoid installing globally and use same command line to work we are using npx

ref:
https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b
https://flaviocopes.com/npx/

Run some code using a different Node version
Use the @ to specify the version, and combine that with the node npm package:

npx node@6 -v #v6.14.3
npx node@8 -v #v8.11.3
This helps to avoid tools like nvm or the other Node version management tools.

npx vs npm:

Simple Definition:

npm - Javascript package manager

npx - Execute npm package binaries

-------------------------------------------------------------------------

Semantic Versioning using npm:

Semantic Versioning is a convention used to provide a meaning to versions
If there’s one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: x.y.z.

the first digit is the major version
the second digit is the minor version
the third digit is the patch version
When you make a new release, you don’t just up a number as you please, but you have rules:

you up the major version when you make incompatible API changes
you up the minor version when you add functionality in a backward-compatible manner
you up the patch version when you make backward-compatible bug fixes
The convention is adopted all across programming languages, and it is very important that every npm package adheres to it, because the whole system depends on that.


Why is that so important?

Because npm set some rules we can use in the package.json file to choose which versions it can update our packages to, when we run npm update.

The rules use those symbols:

^
~
>
>=
<
<=
=
-
||

Let’s see those rules in detail:

^: if you write ^0.13.0 when running npm update it can update to patch and minor releases: 0.13.1, 0.14.0 and so on.
~: if you write ~0.13.0, when running npm update it can update to patch releases: 0.13.1 is ok, but 0.14.0 is not.
>: you accept any version higher than the one you specify
>=: you accept any version equal to or higher than the one you specify
<=: you accept any version equal or lower to the one you specify
<: you accept any version lower to the one you specify
=: you accept that exact version
-: you accept a range of versions. Example: 2.1.0 - 2.6.2
||: you combine sets. Example: < 2.1 || > 2.6
You can combine some of those notations, for example use 1.0.0 || >=1.1.0 <1.2.0 to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

no symbol: you accept only that specific version you specify (1.2.1)
latest: you want to use the latest version available


ref: https://flaviocopes.com/npm-semantic-versioning/

-------------------------------------------------------------------------

The package.json guide

The package.json file is a key element in lots of app codebases based on the Node.js ecosystem.

The package.json file is kind of a manifest for your project. It can do a lot of things, completely unrelated. It’s a central repository of configuration for tools, for example. It’s also where npm and yarn store the names and versions of the package it installed.

there are lots of things going on here:

name - sets the application/package name
version - indicates the current version
description -  is a brief description of the app/package
main - set the entry point for the application
private - if set to true prevents the app/package to be accidentally published on npm
scripts - defines a set of node scripts you can run
dependencies -  sets a list of npm packages installed as dependencies
devDependencies -  sets a list of npm packages installed as development dependencies
engines - sets which versions of Node this package/app works on
browserslist -  is used to tell which browsers (and their versions) you want to support


name:
Sets the package name.

Example:

"name": "test-project"
The name must be less than 214 characters, must not have spaces, it can only contain lowercase letters, hyphens (-) or underscores (_).

This is because when a package is published on npm, it gets its own URL based on this property.

If you published this package publicly on GitHub, a good value for this property is the GitHub repository name.

author:
Lists the package author name

Example:

{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
Can also be used with this format:

{
  "author": {
    "name": "Flavio Copes",
    "email": "flavio@flaviocopes.com",
    "url": "https://flaviocopes.com"
  }
}


contributors:
As well as the author, the project can have one or more contributors. This property is an array that lists them.

Example:

{
  "contributors": [
    "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
  ]
}
Can also be used with this format:

{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "flavio@flaviocopes.com",
      "url": "https://flaviocopes.com"
    }
  ]
}


bugs:
Links to the package issue tracker, most likely a GitHub issues page

Example:

{
  "bugs": "https://github.com/flaviocopes/package/issues"
}


homepage:
Sets the package homepage

Example:

{
  "homepage": "https://flaviocopes.com/package"
}


version:
Indicates the current version of the package.

Example:

"version": "1.0.0"
This property follows the semantic versioning (semver) notation for versions, which means the version is always expressed with 3 numbers: x.x.x.

The first number is the major version, the second the minor version and the third is the patch version.

There is a meaning in these numbers: a release that only fixes bugs is a patch release, a release that introduces backward-compatible changes is a minor release, a major release can have breaking changes.

license
Indicates the license of the package.

Example:

"license": "MIT"
keywords
This property contains an array of keywords that associate with what your package does.

Example:

"keywords": [
  "email",
  "machine learning",
  "ai"
]
This helps people find your package when navigating similar packages, or when browsing the https://www.npmjs.com/ website.

description
This property contains a brief description of the package

Example:

"description": "A package to work with strings"
This is especially useful if you decide to publish your package to npm so that people can find out what the package is about.

repository
This property specifies where this package repository is located.

Example:

"repository": "github:flaviocopes/testing",
Notice the github prefix. There are other popular services baked in:

"repository": "gitlab:flaviocopes/testing",
"repository": "bitbucket:flaviocopes/testing",
You can explicitly set the version control system:

"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
You can use different version control systems:

"repository": {
  "type": "svn",
  "url": "..."
}
main
Sets the entry point for the package.

When you import this package in an application, that’s where the application will search for the module exports.

Example:

"main": "src/main.js"
private
if set to true prevents the app/package to be accidentally published on npm

Example:

"private": true
scripts
Defines a set of node scripts you can run

Example:

"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
These scripts are command line applications. You can run them by calling npm run XXXX or yarn XXXX, where XXXX is the command name. Example: npm run dev.

You can use any name you want for a command, and scripts can do literally anything you want.

dependencies
Sets a list of npm packages installed as dependencies.

When you install a package using npm or yarn:

npm install <PACKAGENAME>
yarn add <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"dependencies": {
  "vue": "^2.5.2"
}
devDependencies
Sets a list of npm packages installed as development dependencies.

They differ from dependencies because they are meant to be installed only on a development machine, not needed to run the code in production.

When you install a package using npm or yarn:

npm install --dev <PACKAGENAME>
yarn add --dev <PACKAGENAME>
that package is automatically inserted in this list.

Example:

"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
engines
Sets which versions of Node.js and other commands this package/app work on

Example:

"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
browserslist
Is used to tell which browsers (and their versions) you want to support. It’s referenced by Babel, Autoprefixer, and other tools, to only add the polyfills and fallbacks needed to the browsers you target.

Example:

"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
This configuration means you want to support the last 2 major versions of all browsers with at least 1% of usage (from the CanIUse.com stats), except IE8 and lower.


ref: https://flaviocopes.com/package-json/
-------------------------------------------------------------------------
The package-lock.json file

The goal of the file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

You don’t commit to Git your node_modules folder, which is generally huge, and when you try to replicate the project on another machine by using the npm install command, if you specified the ~ syntax and a patch release of a package has been released, that one is going to be installed. Same for ^ and minor releases.

If you specify exact versions, like 0.13.0 in the example, you are not affected by this problem.

It could be you, or another person trying to initialize the project on the other side of the world by running npm install.

So your original project and the newly initialized project are actually different. Even if a patch or minor release should not introduce breaking changes, we all know bugs can (and so, they will) slide in.

The package-lock.json sets your currently installed version of each package in stone, and npm will use those exact versions when running npm install.

This concept is not new, and other programming languages package managers (like Composer in PHP) use a similar system for years.

The package-lock.json file needs to be committed to your Git repository, so it can be fetched by other people, if the project is public or you have collaborators, or if you use Git as a source for deployments.

The dependencies versions will be updated in the package-lock.json file when you run npm update.


An example
This is an example structure of a package-lock.json file we get when we run npm install cowsay in an empty folder:

{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz"
,
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",

      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}

Each package contains three fields such as,
version - semantic versions
resolved - that points to the package location
integrity - string that can use to verify the package

ref:https://flaviocopes.com/package-lock-json/
